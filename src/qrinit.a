; this calculates all sizes according to the length of the content
; accumulator holds bank of address
; $fb address lb
; $fc address hb

k_primm   = $ff7d; works for c128 and mega65

qrinit
!zone init
    ; contentlength is taken from qr_url_length
;    sta contentLength

    lda z_location
    sta m_zpal
    lda z_location+1
    sta m_zpal+1

    lda z_location2
    sta m_zpal2
    lda z_location2+1
    sta m_zpal2+1

;    stx z_location
;    sty z_location+1
        
    ; save zero-page values for later recovery
    ldy z_counter1
    sty m_zpa1
    ldy z_counter1+1
    sty m_zpa1+1
    
    ldy z_counter2
    sty m_zpa2
    ldy z_counter2+1
    sty m_zpa2+1
    
    ldy z_temp
    sty m_zpa4
    ldy z_temp+1
    sty m_zpa4+1
    
    
    ; store some zero-page values for later recovery. and set these to value zero
    ldx #1
-   lda z_zp4,x
    sta m_zp4,x
    lda #0
    sta z_zp4,x
    dex
    bne -

        
    ; usually the output address for petscii-to-ascii conversion
    ; we only have ascii here anyways
    ; so this is where we can read the readily available URL from
    ldx #<qr_url
    stx z_location2
    ldx #>qr_url
    stx z_location2+1
        
;calculate version.
    ; decreasing the version boundaries by one byte, because of mode and length bits (eg lower than 108)
    ; max supported version is 5 -> 108 bytes -2=106
    
+   lda #qr_url_length
    sta contentLength
    
    cmp #18
    bcs +
    lda #21
    sta size
    lda #<441
    sta matrixSize
    lda #>441
    sta matrixSize+1
    lda #7
    sta eccLength
    lda #26
    sta streamLength
    lda #0
    sta rsDivisorOffset
    jmp ++
    
+   cmp #33
    bcs +
    lda #25
    sta size
    lda #<625
    sta matrixSize
    lda #>625
    sta matrixSize+1
    lda #10
    sta eccLength
    lda #44
    sta streamLength
    lda #7
    sta rsDivisorOffset
    jmp ++

!if max_version > 2 {    
+   cmp #54
    bcs +
    lda #29
    sta size
    lda #<841
    sta matrixSize
    lda #>841
    sta matrixSize+1
    lda #15
    sta eccLength
    lda #70
    sta streamLength
    lda #17
    sta rsDivisorOffset
    jmp ++
}


; content too long for this
!if knows_primm {
+   jsr k_primm

} else {

+   ldx #0
-   lda .too_long,x
    beq .end
    jsr $ffd2
    inx
    jmp -
}
.too_long  !pet "content is too long.",0

; done
.end
    sec
++  rts

