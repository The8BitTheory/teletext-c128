; this renders the qr-code to pixeldata that's intended for vdc-display
;  the 29x29 code (which it is very likely to be) will be displayed as 15x15 characters
;  this is very close to the original petscii 1x1 render.a
; z_location contains the pointer to read from
; z_location2 is the pointer to write the sprite pixels to.

renderspr

!zone render

    jsr set_location_to_data
    ldy #0                    ;y holds the column (reset to zero after eol is reached)
    ; z_location2 will hold the value of spriteOut times 64l
    sty z_location2
    sty z_location2+1
    
    ;calculate pixel output address. comes after data (same as datastream location in previous steps)
    ; m_l3: store z_location2 for later return to caller. current value will be changed.

    clc
    lda #<data
    adc matrixSize
    sta z_location2
    sta m_l3
    
    lda #>data
    adc matrixSize+1
    sta z_location2+1
    sta m_l3+1

            
.handle_col
    lda (z_location),y
    bit .m_64   ;is xor-bit set?
    bvc .write_value  ;branch if this bit is not xored
    
    pha
    and #1
    sta z_temp
    pla
    and m_maskbit
    bne +
    lda #0
    jmp ++
+   lda #1
++  eor z_temp
    
.write_value
    bit .m_one
    beq +
    lda #$00
    jmp ++

    ; white module (prints inverse space)
+   lda #$ff
    ; if sprite bit is zero (carry flag set), sprite byte is full
++  sta (z_location2),y
    
    ;move on
+   iny
    cpy size
    bne .handle_col
    
    ; finish line
    ldy #0
    jsr .inc_line2
    jsr inc_line  
    cmp m_endAddress    ;needs to have z_location in accumulator
    beq .end
    jmp .handle_col

.end
    rts
    
    
.inc_line2    
    clc
    lda z_location2
    adc size
    sta z_location2
    bcc +
    inc z_location2+1

+   rts

.m_one          !byte 1
.m_64           !byte 64
m_l3           !byte 0,0
